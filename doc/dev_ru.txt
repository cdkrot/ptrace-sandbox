sandboxer - разработка, схема и TODO

На текущий момент
=================
Сейчас важно написать минимальный работоспособный скелет для дальнейшего
допиливания. Важно предусмотреть все факапы, связанные с многопоточностью и
исключить все возможности для багования.

Для обеспечения безбажности предлагается тестировать код после _каждого_ коммита,
используя стресс-тестирование.
Коммиты, ломающие что-нибудь, недопускаются, даже если это исправляется уже в следующем
коммите.


СХЕМА ПРОЕКТА ПО ФАЙЛАМ
=======================
Весь код модуля находится в src/module и в ./build-скрипте является модулем
module. Заголовочные файлы:

src/module/probes.h  - всё, что связано с kprobes
src/module/mentor.h  - struct mentor_stuff и тому подобное
src/module/splay.h   - splay-деревья
src/module/hashmap.h - hashmap
src/module/proc.h    - реализация поведения файлов в /proc/sandboxer
src/module/slot.h    - struct sandbox_slot и всё к нему относящееся
src/module/init.h    - Утилита для написания кода, посвящённого иниициализации и наоборот.

Код по исходникам:
src/module/core.c    - init / shutdown
src/module/probes.c  - kprobes и обработчики системных вызовов
src/module/mentor.c  - всё, относящееся к struct mentor_stuff
src/module/splay.c   - splay-деревья
src/module/hashmap.c - реализация hashmap
src/module/proc.c    - поведение файлов в /proc/sandboxer
src/module/slot.c    - всё, относящееся к struct sandbox_slot
src/module/init.c    - реализация init.h

Подробнее об этом:

src/module/init.h, src/module/init.c
====================================
Содержит полезные функции, упрощающие написание инициализации и
деинициализации.

Прототипы соответсвующих функций:

int initlib_init(void); /* Инициализирует систему инициализации, возвращает errno */

// init_func(1, data) - выполнить инициализацию.
// init_func(0, data) - выполнить деинициализацию.
// init_func возвращает errno, второй вызов должен возвращать 0.
//
// initlib_push выполняет инициализацию (первый вызов). Если он облажается, то
// эта же функция отменяет все накопленные инициализации и возвращает errno из
// вызова init_func(1, data).
//
// Можно использовать одну и ту же функцию инициализации с разной data, что
// должно позволить сократить количество похожего кода.
int initlib_push(int (*init_func)(int is_init, void* data), void* data);

// То же самое, но ещё умеет печатать сообщение если инициализация провалится.
int initlib_push(int (*init_func)(int is_init, void* data), void* data, char* errmsg);

// Отменяет все иниициализации.
void initlib_pop_all(void)

Вопросы синхронизации: всё выполняется в один поток во время инициализации или наоборот.

src/module/probes.h
===================
Содержит функции, связанные с kprobes:

int sandboxer_init_probes(void);

Первая функция регистрирует все нужные пробы через initlib их потом было просто
убрать.
Возвращает errno.

int init_or_shutdown_kprobe(int is_init, void* kp); // *kp - struct kprobe
int init_or_shutdown_jprobe(int is_init, void* jp); // *jp - struct jprobe
int init_or_shutdown_kretprobe(int is_init, void* krp); // *krp - struct kretprobe

Вспомогательные функции для предудыщего пункта. Используются совместно с initlib.

На текущий момент не существует способа убирать kprobe'ы в процессе
исполнения. Как и необходимости это делать.

Вопросы синхронизации: всё выполняется в один поток в процессе инициализации или наоборот.

src/module/splay.h
==================
{INLINE DISCUSSION} здесь и много где далее не описано разделение .h/.c

splay-деревья. Реализованы они максимально просто, что в теории должно
сокращать возможность багов до минимума.

Вопросы синхронизации: требует внешней синхронизации, должно выполняться не более
одного запроса одновременно. Все операции считаются как write (меняющими данные).

struct splay_tree_node {
    struct splay_tree_node *L, *R, *par;    
};

Для использования структуры следует использовать похожее на используемое в
list'ах в Linux решение:

struct foo {
    int a;
    struct splay_tree_node node;
};

Для получения элемента по node: 

struct splay_tree_node n;
struct foo *f = container_of(n, struct foo, node);

Все операции на дереве выражаются через следующу операцию, работающую в худшем
случае долго, однако имеющую амортизированную оценку O(log n) на действие, где
n - количество элементов в дереве. Эта операция преобразует дерево так, что v
становится его корнем.

struct splay_tree_node *splay(struct splay_tree_node *v);

Все остальные функции предлагается реализовывать для каждой задачи отдельно.
Так, функцию find можно писать так же, как и в любом бинарном дереве:

struct splay_tree_node *find(struct splay_tree_node *root, int val) {
    struct foo *f;

    if (!root)
        return NULL;
    f = container_of(root, struct foo, node);
    if (f->a == val)
        return root;
    elif (val < f->a)
        return find(root->L, val);
    else
        return find(root->R, val);
}

Стоит заметить, что для корректной работы амортизированной оценки желательно
после каждой операции find делать splay найденого элемента. Возможны и другие 
реализации, к примеру, нерекурсивные. Подобная гибкость может показаться 
относительно бессмысленной, так как при каждом использовании splay-деревьев 
приходится переписывать часть кода, однако она же даёт возможность написания 
своих компараторов, что может быть использовано очень гибко; к примеру, для 
написания деревьев по неявному ключу. Кроме того, использование именно
splay-деревьев позволяет максимально сократить переписываемый код и сократить
количество багов за счёт простоты. Ещё несколько операций для struct foo:

struct splay_tree_node *merge(struct splay_tree_node *u, 
        struct splay_tree_node *v) {
    if (!u)
        return v;
    if (!v)
        return u;
    while (u->R)
        u = u->R;
    u = splay(u);
    u->R = v;
    v->par = u;
}

[не тестировано!]
struct splay_tree_node *lower_bound(struct splay_tree_node *root, int val) {
    struct foo *f, *g;
    struct splay_tree_node *ret;

    if (!root)
        return NULL;
    f = container_of(root, struct foo, node);
    if (f->a == val)
        return root;
    if (val < f->a) {
        ret = lower_bound(root->L, val);
        if (!ret)
            return root;
        g = container_of(ret, struct foo, node);
        if (f->a < g->a)
            return root;
        else
            return ret;
    } else {
        return lower_bound(root->R, val);
    }
}

[не тестировано!]
void split(struct splay_tree_node *root, int val,
        struct splay_tree_node **lt, struct splay_tree_node **rt) {
    struct splay_tree_node *v;

    v = lower_bound(root, val);
    if (!v) {
        *lt = root;
        *rt = NULL;
        return;
    }
    root = splay(v);
    *lt = root->L;
    *rt = root;
    root->L = NULL;
    if (*lt)
        (*lt)->par = NULL;
}

[не тестировано!]
struct splay_tree_node *add(struct splay_tree_node *root, 
        struct splay_tree_node *v) {
    struct foo *f;

    f = container_of(v, struct foo, node);
    split(root, f->val, &(v->L), &(v->R));
    if (v->L)
        v->L->par = v;
    if (v->R)
        v->R->par = v;
    return v;
}

struct splay_tree_node *remove(struct splay_tree_node *root, 
        struct splay_tree_node *v) {
    root = splay(v);
    root = merge(root->L, root->R);
    return root;
}

src/module/mentor.h
===================
Вопросы синхронизации: все данные, имеющие отношение к сплей защищены персональным локом
на данный сплей.
Запросы на создание или удаление mentor_stuff _только_ от этой задачи.
Изменения данных в mentor_stuff защищаются локом в mentor_stuff.

всё, что связано с struct mentor_stuff

struct mentor_stuff {
    pid_t pid;
    wait_queue_t msg_wq;

    /* TODO: добавить структуру для сообщений */
    /* TODO: добавить в описание lock/semaphore */
    struct splay_tree_node node;
};


{INLINE DISCUSSION} Мне кажется, что логично так:
(Потому что semaphore более простая структура синхронизации чем WQ)
struct mentor_stuff {
    pid_t pid;
    struct splay_tree_node node;
    struct spinlock_t lock; /* общая синхронизация данных в структуре */
    struct notification queue[CNT];
    size_t queue_begin;
    size_t queue_end;
    struct semaphore_t sem; /* Обеспечивает ожидание */
};

Все активные mentor_stuff хранятся в M splay-деревьях, упорядочеенных по pid,
а именно в k-том splay-дереве хранится информация про всех менторов, у которых
pid % M == k.

enum mentor_stuff_request {
    MENTOR_GET,
    MENTOR_GET_OR_CREATE,
    MENTOR_CREATE,
    MENTOR_DESTROY,
    MENTOR_SOFT_DESTROY
};

struct mentor_stuff *manage_mentor_suff(pid_t pid, 
        enum mentor_stuff_request mode);

Пожалуй, здесь в комментариях нуждается только MENTOR_SOFT_DESTROY. В отличие
от MENTOR_DESTROY, он просто игнорирует запрос, если mentor_stuff в дереве не
найден. В MENTOR_DESTROY же стоит BUG_ON.

int init_mentor_stuff(void);
void shutdown_mentor_stuff(void);

Комментарии излишни.

Кроме того, в этом файле содержится API, связанное с отправкой сообщений.
Общая идея этого такова: если sandboxer считает, что ментору надо отправить
сообщение, он останавливает своё выполнение в текущем процессе и становится в 
msg_wq. Когда до него дойдёт очередь, он обновит текущее сообщение в struct
mentor_stuff и продолжит выполнение.

{INLINE DISCUSSION}
Собственно предлагаю из этого подмодуля экспортировать только API для отправки/получения сообщений.
enum nofication_type {
    NOTIFICATION_ABA,
    NOTIFICATION_CABA
};
struct notification {
    notification_type type;
    size_t slot_id;
    size_t extra_field1;
    size_t extra_field2;
};
void send_notification(struct sandbox_slot* slot, const struct notification*);
int  recv_notification(struct task_struct* mentor, struct notification*); // через return показываем есть ли нотификация.

{TODO:} Нужно предусмотреть ситуацию, когда mentor может сдохнуть в процессе обработки какого-то
события в его слоте. Нужно где-то попросить ядро не убивать mentor в данный момент времени.
Вопрос как.

src/module/hashmap.{c,h}
========================
{TODO}

src/module/proc.h
=================
Всё, что связано с /proc.

int init_sandboxer_proc(void);
void shutdown_sandboxer_proc(void);

Первая функция создаёт директорию /proc/sandboxer/ и в ней файлы
/proc/sandboxer/sandbox-me и /proc/sandboxer/notifier. Вторая функция удаляет
директорию /proc/sandboxer/ и всё, что в ней.

void sb_add_slot_entry(char *name, (void *cb)(struct seq_file *, u8));

Должно быть вызвано после init_sandboxer_proc, но до окончания инициализации
модуля. После вызова в каждой из директорий /proc/sandboxer/[slot_id]/ будет
создаваться файл с именем name, при этом в момент чтения будет вызвана функция
cb. Пример функции cb:

void proc_slotid_maxmem_cb(struct seq_file *s, u8 slot_id) {
    seq_printf(s, "%lu", slots[slot_id].max_mem_used);
}

Как-то так.

void create_slotid_dir(struct sandbox_slot *s);
void destroy_slotid_dir(struct sandbox_slot *s);

Добавляют и удаляют слот при его открытии и закрытии.

src/module/slot.h
=================
Вопросы синхронизации.
Запросы на создание/удаление защищаются (видимо) как-то отдельно.
Все* запросы к sandbox_slot защищаются локом внутри него.
Создание слота происходит в один поток и потому безопасно (но нужно предусмотреть защиту поля Mentor в данном случае {TODO}).
Удаление слота происходит только когда num_alive = ref_cnt = 0, следовательно единственный
поток имеющий отношение к нему - текущий, потому удаление безопасно. Но при этом требуется синхронизация по полю mentor.

* КРОМЕ ЗАПРОСОВ К ПОЛЮ MENTOR, оно защищается локами из подмодуля mentor.

всё, что связано с struct sandbox_slot.

struct sandbox_slot {
    struct task_struct *mentor; // pointer to mentor, or null, if it died

    size_t num_alive; // num of alive pids inside.
    size_t ref_cnt;

    size_t slot_id; // only for purpose of userspace IO.

    size_t mem_used; // self explaining
    size_t max_mem_used;
    size_t mem_limit;

    size_t time_used; // self explaining
    size_t time_limit;

    struct spinlock_t lock; /* protects all data inside */

    struct proc_dir_entry slotid_dir; /* handle to /proc entry (via src/module/proc.{c,h})
};


bool is_sandboxed(pid_t pid);

Возвращает, сандбоксируется ли процесс. Ответ на этот вопрос реализован через
hashset фиксированного размера. sandboxer поддерживает одновременное
сандбоксирование не более чем константного числа процессов, являющегося
параметром при загрузке модуля (insmod). Попытка открыть новый слот при
достижении этого числа процессов будет поучать ошибку -EBUSY, попытка сделать
новый процесс в слоте будет получать ошибку -EFAULT. Размер хешсета равен
минимальному простому числу, большему учетвенённого числа поддерживаемых
процессов.

{INLINE DISCUSSION}
struct slot* get_sandbox_slot(struct task_struct*); /* or null */
Чтобы не делать два отдельных вызова is_sandboxed и get_slot().

int init_or_shutdown_slots(void);

int init_sandbox_slots(void); // использует initlib и пред. функцию.

Комментарии снова излишни.

struct sandbox_slot* get_slot_of(struct task_struct *);
struct sandbox_slot* create_new_slot(void); // pid = current->pid, mentor = current->parent, {TODO} защититься от самоуничтожения mentor в момент создания слота.

void release_slot(struct sandbox_slot*);

Видимо как-то так.


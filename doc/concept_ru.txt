sandboxer - концепция проекта

Основные положения
==================

1. sandboxer позволяет детально контролировать выполнение процесса или группы
процессов в userspace путём перехвата и обработки системных вызовов.
2. На текущий момент поддерживается поддерживается и может поддерживаться
только платформа [GNU/]Linux.
3. Отличие sandboxer от ptrace - нативного механизма ядра Linux для обработки
системных вызовов - быстродействие, достигающееся за счёт обработки большей
части системных вызовов в kernel space без остановки процесса. 
[в используемом в текущем концепте механизме перехвата системных вызовов через
kprobes имеет место быть ускорение по сравнению с ptrace в десятки раз.
Подробнее - см. issue #8 на github.]
4. sandboxer выпускается и тестируется на рабочих версиях ядра и не может
требовать применения специальных патчей к нему для корректной работы. Впрочем,
он может требовать включения нужных опций в конфигурации ядра.
5. Основной частью проекта является модуль к ядру Linux. Кроме того,
предоставлены userspace-утилиты как образец использования модуля или
предполагаемый вариант использования.
6. Сигнал к началу сандбоксинга подаётся процессом, который требуется
контролировать.
7. Ментором (контролирующим процессом) является родитель сандбоксируемого
процесса. Все потомки изначально сандбоксируемого процесса объединяются в один
слот и контролируются изначальным ментором.
8. sandboxer не обрабатывает информацию о системных вызовах, совершённых
процессами, не входящими ни в один слот.
9. sandboxer не влияет на исполнение сандбоксируемых процессов никаким
образом, кроме их остановки. Любые сигналы этим процессам должны посылаться
ментором.
10. sandboxer не влияет никаким образом на исполнение процесса, являющегося
ментором какого-либо слота. Но он предоставляет возможность взаимодействия с
собой через файлы в /proc.

Основные понятия
================

sandboxer предоставляет интерфейс для контроля процесса-"ребёнка" (child),
находящегося в "песочнице" (sandbox) под присмотром "ментора" (mentor).

Песочница является лишь абстрактным объектом, испольуемым для обозначения
процесса сандбоксинга.

Потомки одного процесса, находящегося в песочнице, возникшие в процессе
сандбоксинга, объединяются в один "слот" (slot). Все системные вызовы всех
процессов в одном слоте в соответствии с интерфейсом, предоставляемым модулем,
контролируются одним ментором.

Обсуждение
==========
Положения. 4. Предлагаю в долгосрочной перспективе поддерживать все ядра >= текущего
ядра дебиана. Пока будем тестировать на mainline, конечно. Также мы подразумеваем, что
требуемые опции ядра включены на стандартных сборках.

pl: а более ранние не? а почему бы и не? про включены на стандартных сборках -
    понятно, что подразумевается, но писать в концепт странно, т.к. очевидно в
    разных репах разные конфиги ядра в стандартных сборках. понятно, что на
    ubuntu/debian/arch стоит перед релизом проверять.

ck: В дебиане сейчас кажется 3.20, в stable. Ты точно хочешь ещё более рание?

pl: в слаке, допустим, 3.10. и мало ли какие динозавры по паркам юрского
    периода бродят.

ck: Они наркоманы. Я просто не уверен, что будет просто такое поддерживать, но ок.

Положения. 9. Есть предложение предусмотреть опцию, предусматривающую "мягкий"
сандбоксинг. Тогда вместо немедленного убийства виновного процесса мы доставляем -EPERM
или -ENOMEM из системного вызова.
Также не описано убивается ли только один процесс или весь слот [логично второе].
Не понял "Любые сигналы этим процессам должны посылаться ментором". Зачем это?

pl: убивается, видимо, весь слот. а надо ли посылать SIGKILL из кернелспейса?
    мне кажется, что в любом случае логично, когда это решение принимает
    ментор.

ck: А почему бы не послать SigKill из kernelspace-а?
    "логично, когда это решение принимает ментор.", тоесть сделаем опцией при старте сандбокса?

pl: "ну мне бы на месте ментора было обидно. я сам хочу пристукнуть своего
    воспитанника!". хрен с тобой, золотая рыбка, пусть будет опцией.

ck: Мне хочется, чтобы взаимодействием с ментором было максимально не интерактивным (т.е. только
    в одну сторону), а то мы получаем в точности ту же проблему, что и с ptrace.
    Медленно.

    Я правильно понимаю, что у нас опция имеет такие возможные значения:
    SOFT - Отдаём плохишам -EPERM или -ENOMEM
    SOFT+NOTIFY - Тоже самое, но ещё и посылаем уведомление.
    KILL+NOTIFY - Убиваем и говорим об этом.

    И я всё ещё не понял значение фразы "Любые сигналы этим процессам должны посылаться ментором".

Положения. 10. Зачем отдельно описывать, что sandboxer не влияет на исполнение менторов?
Мы хотим, чтобы он не влиял на исполнение всех процессов, кроме тех, что внутри слотов.

pl: чтобы не забываться и не хотеть общаться с ментором посредством сигналов
    (ну было же обсуждение)

ck: Окей, принято.

Положения. Ещё. Нужно отдельно описать что должно случится, если процесс, сидящий в сандбоксе,
запросил создание нового слота. Мы будем поддерживать вложенные слоты или нет?

pl: а надо? мне не жалко, но.. зачем?

ck: Нуууу, потому что можем? Впрочем не знаю, но если окажется сделать просто, то почему бы и нет.

pl: ну а разве сложно? и да, почему бы ему не работать и так? чего туда
    дописывать?

ck: Ну оно будет работать за O(H), каждая операция выделения памяти.
    Что в случае бамбука плохо.
    Видимо нужно ставить тогда лимит на макс. H.

    Просто так оно, разумеется, работать не будет.
    Лимит памяти из верхнего слота должен также ограничивать память в нижнем.

    В целом я понимаю, что не маст-хев фича, также можно отложить.
    Но тогда надо запрещать подслоты делать.

Ещё хочется понять что мы делаем если ментор внезапно умирает до своих слотов?
(Убивать ли слот или нет?). Видимо нужно сделать опцией.

pl: нужно.

Ещё хочется написать, что один ментор может следить за несколькими слотами.

pl: ОК

Мерж то, по чему консенс в общий документ.

